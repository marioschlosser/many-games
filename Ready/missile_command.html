<!DOCTYPE html>
<html>
<head>
    <title>Missile Command</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 20px auto;
        }
        body {
            background-color: #000;
            color: #fff;
            text-align: center;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
    <h1>Missile Command</h1>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        // Game constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const CITY_WIDTH = 60;
        const CITY_HEIGHT = 50;
        const BASE_WIDTH = 60;
        const BASE_HEIGHT = 40;
        const MISSILE_SPEED = 1.5;
        const ABM_SPEED = 5;
        const EXPLOSION_MAX_RADIUS = 40;
        const EXPLOSION_GROWTH_RATE = 0.5;
        const SPAWN_INTERVAL_MS = 2000;  // Base spawn interval
        const EXPLOSION_DURATION = 120;   // Frames the explosion lasts
        const POINTS_PER_IBM = 25;
        const POINTS_PER_CRUISE = 125;
        const POINTS_PER_UNUSED_ABM = 5;
        const POINTS_PER_SAVED_CITY = 100;
        const POINTS_FOR_BONUS_CITY = 10000;
        const WAVE_MULTIPLIERS = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6]; // Score multipliers per wave
        const FLASH_INTERVAL = 100; // ms between flashes
        const CITY_COLORS = ['#00ff00', '#00dd00', '#00bb00'];
        const BASE_COLORS = ['#0000ff', '#0000dd', '#0000bb'];
        const STREAK_THRESHOLD = 3;  // Hits needed for first power-up
        const MAX_STREAK_LEVELS = 4; // Number of power-up levels available
        const EXPLOSION_BOOST_DURATION = 15000;  // 15 seconds
        const SPEED_BOOST_DURATION = 30000;     // 30 seconds

        // Add power-up selection menu
        class PowerUpMenu {
            constructor() {
                this.options = [
                    { name: "Wider Explosions", description: "15s bigger boom" },
                    { name: "Faster ABMs", description: "30s speed boost" },
                    { name: "Rebuild City", description: "Restore 1 city" },
                    { name: "Triple Shot", description: "3 missiles per shot" }
                ];
                this.selected = 0;
                this.visible = false;
            }

            draw() {
                if (!this.visible) return;

                // Semi-transparent background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Draw menu title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Select Power-Up', CANVAS_WIDTH/2, CANVAS_HEIGHT/3);

                // Draw available power-ups based on streak level
                const availableOptions = Math.min(gameState.maxStreakReached, this.options.length);
                
                for (let i = 0; i < availableOptions; i++) {
                    const option = this.options[i];
                    const x = CANVAS_WIDTH/2;
                    const y = CANVAS_HEIGHT/2 + (i * 50);
                    
                    // Highlight selected option
                    if (i === this.selected) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(x - 150, y - 20, 300, 40);
                    }
                    
                    ctx.fillStyle = i === this.selected ? '#000' : '#fff';
                    ctx.font = '20px Arial';
                    ctx.fillText(`${i + 1}. ${option.name} - ${option.description}`, x, y);
                }
            }
        }

        // Game state
        const powerUpMenu = new PowerUpMenu();
        let gameState = {
            cities: [],
            base: null,
            enemyMissiles: [],
            playerMissiles: [],
            explosions: [],
            score: 0,
            cursor: { x: 0, y: 0 },
            abmSupply: [10, 10, 10],
            currentSupply: 0,
            bonusCities: 0,
            lastScore: 0,
            gameOver: false,
            wave: 1,
            missilesThisWave: 0,
            missilesRemaining: 0,
            missileSpeed: MISSILE_SPEED,
            spawnInterval: SPAWN_INTERVAL_MS,
            lastSpawnTime: 0,
            waveComplete: false,
            showingWaveScreen: false,
            waveStartTime: 0,
            currentStreak: 0,
            maxStreakReached: 0,
            powerUpAvailable: false,
            activePowerUps: {
                explosionBoost: { active: false, endTime: 0, multiplier: 1 },
                speedBoost: { active: false, endTime: 0, multiplier: 1 },
                tripleShot: false
            },
            paused: false
        };

        // Initialize canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Classes
        class City {
            constructor(x) {
                this.x = x;
                this.y = CANVAS_HEIGHT - CITY_HEIGHT;
                this.width = CITY_WIDTH;
                this.height = CITY_HEIGHT;
                this.health = 5;  // 5 lives
                this.destroyed = false;
                this.colorIndex = 0;
                this.lastFlash = 0;
                this.windows = [];
                this.damagePoints = [];  // Track where the city has been hit
                
                // Create window pattern (more windows for bigger city)
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 3; j++) {
                        this.windows.push({
                            x: this.x + 8 + (i * 14),
                            y: this.y + 8 + (j * 14),
                            lit: Math.random() > 0.5
                        });
                    }
                }
            }

            update(currentTime) {
                if (!this.destroyed) {
                    // Animate city colors
                    if (currentTime - this.lastFlash > FLASH_INTERVAL) {
                        this.colorIndex = (this.colorIndex + 1) % CITY_COLORS.length;
                        this.lastFlash = currentTime;
                        
                        // Randomly toggle windows
                        this.windows.forEach(window => {
                            if (Math.random() < 0.1) window.lit = !window.lit;
                        });
                    }
                }
            }

            damage() {
                this.health--;
                // Add a damage point at a random position on the building
                this.damagePoints.push({
                    x: this.x + Math.random() * this.width,
                    y: this.y + Math.random() * this.height,
                    size: Math.random() * 15 + 10
                });
                if (this.health <= 0) {
                    this.destroyed = true;
                }
            }

            draw() {
                if (!this.destroyed) {
                    // Draw main building
                    ctx.fillStyle = CITY_COLORS[this.colorIndex];
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // Draw windows that haven't been destroyed
                    this.windows.forEach(window => {
                        // Check if window is in a damaged area
                        const isDamaged = this.damagePoints.some(point => {
                            const dx = window.x - point.x;
                            const dy = window.y - point.y;
                            return Math.sqrt(dx * dx + dy * dy) < point.size;
                        });
                        
                        if (!isDamaged) {
                            ctx.fillStyle = window.lit ? '#ffff00' : '#666600';
                            ctx.fillRect(window.x, window.y, 8, 8);
                        }
                    });
                    
                    // Draw roof details
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.width/2, this.y - 15);  // Taller roof
                    ctx.lineTo(this.x + this.width, this.y);
                    ctx.fillStyle = CITY_COLORS[(this.colorIndex + 1) % CITY_COLORS.length];
                    ctx.fill();
                    
                    // Draw damage
                    this.damagePoints.forEach(point => {
                        ctx.fillStyle = '#444444';
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, point.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Draw health indicator
                    const healthBarWidth = this.width - 10;
                    const healthSegmentWidth = healthBarWidth / 5;
                    for (let i = 0; i < this.health; i++) {
                        ctx.fillStyle = '#ff0000';
                        ctx.fillRect(
                            this.x + 5 + (i * healthSegmentWidth), 
                            this.y - 25, 
                            healthSegmentWidth - 2, 
                            5
                        );
                    }
                } else {
                    // Draw complete ruins
                    ctx.fillStyle = '#444444';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height);
                    for(let i = 0; i < this.width; i += 4) {
                        const height = Math.random() * 15 + 5;
                        ctx.lineTo(this.x + i, this.y + this.height - height);
                    }
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.fill();
                }
            }
        }

        class MissileBase {
            constructor() {
                this.x = CANVAS_WIDTH / 2 - BASE_WIDTH / 2;
                this.y = CANVAS_HEIGHT - BASE_HEIGHT;
                this.width = BASE_WIDTH;
                this.height = BASE_HEIGHT;
                this.destroyed = false;
                this.colorIndex = 0;
                this.lastFlash = 0;
                this.turretAngle = 0;
                this.targetAngle = 0;
            }

            update(currentTime, cursorX, cursorY) {
                if (!this.destroyed) {
                    // Animate base colors
                    if (currentTime - this.lastFlash > FLASH_INTERVAL) {
                        this.colorIndex = (this.colorIndex + 1) % BASE_COLORS.length;
                        this.lastFlash = currentTime;
                    }

                    // Update turret angle based on cursor position
                    const dx = cursorX - (this.x + this.width/2);
                    const dy = cursorY - this.y;
                    this.targetAngle = Math.atan2(dy, dx);
                    
                    // Smooth turret rotation
                    const angleDiff = this.targetAngle - this.turretAngle;
                    this.turretAngle += angleDiff * 0.1;
                }
            }

            draw() {
                if (!this.destroyed) {
                    // Draw main base
                    ctx.fillStyle = BASE_COLORS[this.colorIndex];
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                    
                    // Draw base details
                    ctx.fillStyle = BASE_COLORS[(this.colorIndex + 1) % BASE_COLORS.length];
                    ctx.fillRect(this.x + 5, this.y + 5, this.width - 10, 10);
                    
                    // Draw turret
                    ctx.save();
                    ctx.translate(this.x + this.width/2, this.y);
                    ctx.rotate(this.turretAngle);
                    
                    // Turret base
                    ctx.fillStyle = '#0066ff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Turret barrel
                    ctx.fillStyle = '#0044dd';
                    ctx.fillRect(0, -4, 20, 8);
                    
                    ctx.restore();
                } else {
                    // Draw destroyed base
                    ctx.fillStyle = '#444444';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y + this.height);
                    for(let i = 0; i < this.width; i += 4) {
                        const height = Math.random() * 15 + 5;
                        ctx.lineTo(this.x + i, this.y + this.height - height);
                    }
                    ctx.lineTo(this.x + this.width, this.y + this.height);
                    ctx.fill();
                }
            }
        }

        class Missile {
            constructor(startX, startY, targetX, targetY, isEnemy = true) {
                this.startX = startX;
                this.startY = startY;
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.isEnemy = isEnemy;
                this.speed = isEnemy ? gameState.missileSpeed : ABM_SPEED;
                this.calculateVelocity();
                this.trail = [];
                this.lastTrailPos = { x: startX, y: startY };
                this.hitSomething = false;  // Track if this missile's explosion hit anything
            }

            calculateVelocity() {
                const dx = this.targetX - this.startX;
                const dy = this.targetY - this.startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }

            update() {
                // Calculate speed with current multiplier
                let currentSpeed = this.isEnemy ? this.speed : 
                    this.speed * gameState.activePowerUps.speedBoost.multiplier;

                // Update position using current speed
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < currentSpeed) {
                    this.x = this.targetX;
                    this.y = this.targetY;
                    return true;
                }
                
                const vx = (dx / distance) * currentSpeed;
                const vy = (dy / distance) * currentSpeed;
                
                this.x += vx;
                this.y += vy;
                
                // Add current position to trail
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 10) {
                    this.trail.shift();
                }
                
                return false;
            }

            draw() {
                ctx.strokeStyle = this.isEnemy ? '#ff0000' : '#00ff00';
                ctx.lineWidth = 2;

                // Draw trail
                if (this.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    this.trail.forEach(point => {
                        ctx.lineTo(point.x, point.y);
                    });
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                }

                // Draw missile tip
                ctx.fillStyle = this.isEnemy ? '#ffff00' : '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.lineWidth = 1;
            }
        }

        class Explosion {
            constructor(x, y, isEnemy = false) {
                this.x = x;
                this.y = y;
                this.radius = 1;
                // Apply current explosion multiplier
                this.maxRadius = isEnemy ? EXPLOSION_MAX_RADIUS : 
                    EXPLOSION_MAX_RADIUS * gameState.activePowerUps.explosionBoost.multiplier;
                console.log(this.maxRadius);
                this.duration = EXPLOSION_DURATION * gameState.activePowerUps.explosionBoost.multiplier;
                this.active = true;
                this.isEnemy = isEnemy;
                this.particles = [];
                this.hasHitSomething = false;
                
                // Create explosion particles
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * (isEnemy ? 1 : 2),  // Faster particles for player explosions
                        vy: Math.sin(angle) * (isEnemy ? 1 : 2),
                        life: 1
                    });
                }

                // Debug log
                if (!isEnemy) {
                    console.log('New explosion:', {
                        maxRadius: this.maxRadius,
                        baseRadius: EXPLOSION_MAX_RADIUS,
                        multiplier: gameState.activePowerUps.explosionBoost.multiplier,
                        isActive: gameState.activePowerUps.explosionBoost.active
                    });
                }
            }

            update() {
                if (this.radius < this.maxRadius) {
                    this.radius += EXPLOSION_GROWTH_RATE;
                }
                this.duration--;
                
                // Update particles
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                });
                
                if (this.duration <= 0) {
                    this.active = false;
                }
            }

            draw() {
                const alpha = this.duration / EXPLOSION_DURATION;
                
                // Draw main explosion
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = this.isEnemy ? 
                    `rgba(255, 0, 0, ${alpha})` : 
                    `rgba(255, 255, 0, ${alpha})`;
                ctx.stroke();
                
                // Draw particles
                this.particles.forEach(p => {
                    if (p.life > 0) {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
                        ctx.fillStyle = this.isEnemy ? 
                            `rgba(255, 100, 0, ${p.life})` : 
                            `rgba(255, 255, 0, ${p.life})`;
                        ctx.fill();
                    }
                });
            }
        }

        // Initialize game
        function initGame() {
            // Create cities
            const citySpacing = CANVAS_WIDTH / 7;
            for (let i = 0; i < 6; i++) {
                const x = citySpacing * (i + 1) - CITY_WIDTH / 2;
                gameState.cities.push(new City(x));
            }

            // Create missile base
            gameState.base = new MissileBase();

            // Start game loop
            requestAnimationFrame(gameLoop);
            startNewWave();  // Initialize first wave
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Update game state
        function update() {
            const currentTime = Date.now();
            
            if (gameState.showingWaveScreen) {
                // Show wave screen for 3 seconds
                if (currentTime - gameState.waveStartTime > 3000) {
                    gameState.showingWaveScreen = false;
                }
                return;  // Don't update game while showing wave screen
            }
            
            // Update cities and base
            gameState.cities.forEach(city => city.update(currentTime));
            gameState.base.update(currentTime, gameState.cursor.x, gameState.cursor.y);
            
            // Spawn enemy missiles
            if (currentTime - gameState.lastSpawnTime > gameState.spawnInterval) {
                spawnEnemyMissile();
                gameState.lastSpawnTime = currentTime;
            }

            // Update enemy missiles
            for (let i = gameState.enemyMissiles.length - 1; i >= 0; i--) {
                const missile = gameState.enemyMissiles[i];
                if (missile.update()) {
                    // Missile has reached its target
                    handleMissileImpact(missile);
                    gameState.enemyMissiles.splice(i, 1);
                }
            }

            // Update player missiles
            for (let i = gameState.playerMissiles.length - 1; i >= 0; i--) {
                const missile = gameState.playerMissiles[i];
                if (missile.update()) {
                    // Create explosion at target
                    const explosion = new Explosion(missile.targetX, missile.targetY);
                    explosion.playerMissileId = i;  // Track which missile created this explosion
                    gameState.explosions.push(explosion);
                    gameState.playerMissiles.splice(i, 1);
                }
            }

            // Update explosions and check for missile collisions
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                explosion.update();
                
                // Only check enemy collisions for player explosions
                if (!explosion.isEnemy) {
                    // Check for enemy missiles caught in explosion
                    for (let j = gameState.enemyMissiles.length - 1; j >= 0; j--) {
                        const missile = gameState.enemyMissiles[j];
                        if (checkCollision(explosion, missile)) {
                            gameState.score += POINTS_PER_IBM;
                            gameState.enemyMissiles.splice(j, 1);
                            
                            // Increment streak only on first hit for this explosion
                            if (!explosion.hasHitSomething) {
                                gameState.currentStreak++;
                                if (gameState.currentStreak >= STREAK_THRESHOLD) {
                                    gameState.powerUpAvailable = true;
                                    // Calculate which power-up box should be highlighted (0-based index)
                                    gameState.maxStreakReached = 
                                        Math.min(Math.floor((gameState.currentStreak - STREAK_THRESHOLD) / STREAK_THRESHOLD), 
                                                MAX_STREAK_LEVELS - 1);
                                }
                                explosion.hasHitSomething = true;
                            }
                        }
                    }

                    // Only check for streak reset when explosion is nearly finished
                    if (explosion.duration <= 1 && !explosion.hasHitSomething) {
                        resetStreakState();  // Complete reset on miss
                    }
                }

                // Remove inactive explosions
                if (!explosion.active) {
                    gameState.explosions.splice(i, 1);
                }
            }

            // Check game over condition
            checkGameOver();

            // Check for wave completion
            if (gameState.missilesRemaining <= 0 && 
                gameState.enemyMissiles.length === 0) {
                gameState.wave++;
                startNewWave();
            }

            // Update power-up timers
            if (gameState.activePowerUps.explosionBoost.active && 
                currentTime > gameState.activePowerUps.explosionBoost.endTime) {
                gameState.activePowerUps.explosionBoost.active = false;
            }
            
            if (gameState.activePowerUps.speedBoost.active && 
                currentTime > gameState.activePowerUps.speedBoost.endTime) {
                gameState.activePowerUps.speedBoost.active = false;
            }
        }

        // Draw game state
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (gameState.showingWaveScreen) {
                drawWaveScreen();
                return;
            }

            // Draw all game objects in the correct order
            gameState.cities.forEach(city => city.draw());
            gameState.base.draw();
            
            // Draw missiles with proper visibility
            ctx.lineWidth = 2;  // Make lines thicker
            gameState.enemyMissiles.forEach(missile => missile.draw());
            gameState.playerMissiles.forEach(missile => missile.draw());
            ctx.lineWidth = 1;  // Reset line width
            
            gameState.explosions.forEach(explosion => explosion.draw());

            // Draw cursor
            ctx.strokeStyle = '#fff';
            ctx.beginPath();
            ctx.arc(gameState.cursor.x, gameState.cursor.y, 5, 0, Math.PI * 2);
            ctx.stroke();

            // Draw HUD
            drawHUD();

            drawStreakBar();
            powerUpMenu.draw();
        }

        // Draw HUD
        function drawHUD() {
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            
            // Left side info
            ctx.textAlign = 'left';
            ctx.fillText(`Score: ${gameState.score}`, 10, 30);
            ctx.fillText(`Wave: ${gameState.wave}`, 10, 60);
            
            // Show all ABM supplies and current supply
            const totalABMs = gameState.abmSupply.reduce((sum, supply) => sum + supply, 0);
            ctx.fillText(`ABMs: ${totalABMs} (${gameState.abmSupply.join('/')}) Supply #${gameState.currentSupply + 1}`
                , 10, 90);
            
            // Right side info
            ctx.textAlign = 'right';
            ctx.fillText(`Bonus Cities: ${gameState.bonusCities}`, CANVAS_WIDTH - 10, 30);
            ctx.fillText(`Missiles Left: ${gameState.missilesRemaining}`, CANVAS_WIDTH - 10, 60);
            
            // Score multiplier
            const multiplier = WAVE_MULTIPLIERS[Math.min(gameState.wave - 1, WAVE_MULTIPLIERS.length - 1)];
            ctx.fillText(`Multiplier: ${multiplier}x`, CANVAS_WIDTH - 10, 90);
        }

        // Event listeners
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            gameState.cursor.x = e.clientX - rect.left;
            gameState.cursor.y = e.clientY - rect.top;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Check if click is in power-up area
            const barWidth = 200;
            const powerUpY = 120 + 20 + 10;
            const powerUpHeight = 30;
            const powerUpWidth = barWidth / MAX_STREAK_LEVELS;
            const x = CANVAS_WIDTH - barWidth - 10;

            if (clickY >= powerUpY && clickY <= powerUpY + powerUpHeight && 
                clickX >= x && clickX <= x + barWidth) {
                
                const powerUpIndex = Math.floor((clickX - x) / powerUpWidth);
                
                // Only activate if this power-up is available
                if (powerUpIndex === gameState.maxStreakReached && gameState.powerUpAvailable) {
                    activatePowerUp(powerUpIndex);
                    gameState.powerUpAvailable = false;
                    gameState.currentStreak = 0;
                    gameState.maxStreakReached = 0;  // Reset to first box
                    return;
                }
            }

            // Fire ABM if available and not clicking power-up area
            if (!gameState.base.destroyed && 
                gameState.abmSupply[gameState.currentSupply] > 0 && 
                gameState.playerMissiles.length < 3) {
                
                // Check if we have any ABMs left in any supply
                while (gameState.currentSupply < 3 && gameState.abmSupply[gameState.currentSupply] <= 0) {
                    gameState.currentSupply++;
                }
                
                // Only fire if we have ABMs available
                if (gameState.currentSupply < 3 && gameState.abmSupply[gameState.currentSupply] > 0) {
                    const missile = new Missile(
                        gameState.base.x + BASE_WIDTH / 2,
                        gameState.base.y,
                        clickX,
                        clickY,
                        false
                    );
                    
                    gameState.playerMissiles.push(missile);
                    gameState.abmSupply[gameState.currentSupply]--;

                    // If current supply is empty, move to next supply
                    if (gameState.abmSupply[gameState.currentSupply] <= 0 && gameState.currentSupply < 2) {
                        gameState.currentSupply++;
                    }

                    // Handle triple shot power-up
                    if (gameState.activePowerUps.tripleShot) {
                        const baseX = gameState.base.x + BASE_WIDTH / 2;
                        const baseY = gameState.base.y;
                        const angle = Math.atan2(clickY - baseY, clickX - baseX);
                        const spread = Math.PI / 6; // 30 degrees
                        
                        // Left missile - random target near main target
                        const leftDistance = Math.random() * 200 + 100; // Random distance 100-300 pixels
                        const leftAngle = angle - spread + (Math.random() * spread/2 - spread/4); // Add some randomness to angle
                        const leftMissile = new Missile(
                            baseX,
                            baseY,
                            clickX + Math.cos(leftAngle) * leftDistance,
                            clickY + Math.sin(leftAngle) * leftDistance,
                            false
                        );
                        
                        // Right missile - random target near main target
                        const rightDistance = Math.random() * 200 + 100; // Random distance 100-300 pixels
                        const rightAngle = angle + spread + (Math.random() * spread/2 - spread/4); // Add some randomness to angle
                        const rightMissile = new Missile(
                            baseX,
                            baseY,
                            clickX + Math.cos(rightAngle) * rightDistance,
                            clickY + Math.sin(rightAngle) * rightDistance,
                            false
                        );
                        
                        gameState.playerMissiles.push(leftMissile, rightMissile);
                    }
                }
            }
        });

        // Start the game
        initGame();

        // Add these new helper functions
        function spawnEnemyMissile() {
            if (gameState.missilesRemaining <= 0) return;
            
            // Spawn 1-3 missiles at once based on wave number
            const missilesToSpawn = Math.min(
                Math.floor(1 + gameState.wave / 3), 
                3,
                gameState.missilesRemaining
            );
            
            for (let i = 0; i < missilesToSpawn; i++) {
                const startX = Math.random() * CANVAS_WIDTH;
                let targetX;
                
                // 80% chance to target a city, 20% chance to target the base
                if (Math.random() < 0.8) {
                    const aliveCities = gameState.cities.filter(city => !city.destroyed);
                    if (aliveCities.length > 0) {
                        const targetCity = aliveCities[Math.floor(Math.random() * aliveCities.length)];
                        targetX = targetCity.x + CITY_WIDTH / 2;
                    } else {
                        targetX = gameState.base.x + BASE_WIDTH / 2;
                    }
                } else {
                    targetX = gameState.base.x + BASE_WIDTH / 2;
                }

                const missile = new Missile(
                    startX,
                    0,
                    targetX,
                    CANVAS_HEIGHT - 10,
                    true
                );
                
                // Apply wave-specific speed
                missile.speed = gameState.missileSpeed;
                
                gameState.enemyMissiles.push(missile);
                gameState.missilesRemaining--;
                
                if (gameState.missilesRemaining <= 0) break;
            }
        }

        function handleMissileImpact(missile) {
            // Create explosion at impact point
            gameState.explosions.push(new Explosion(missile.x, missile.y, true));  // true for enemy explosion
            
            // Check collision with cities
            for (const city of gameState.cities) {
                if (!city.destroyed && 
                    missile.targetX >= city.x && 
                    missile.targetX <= city.x + CITY_WIDTH) {
                    city.damage();  // Damage instead of instant destruction
                    return;
                }
            }

            // Check collision with base - only if all cities are destroyed
            if (!gameState.base.destroyed && 
                missile.targetX >= gameState.base.x && 
                missile.targetX <= gameState.base.x + BASE_WIDTH) {
                
                // Check if all cities are destroyed
                const allCitiesDestroyed = gameState.cities.every(city => city.destroyed);
                if (allCitiesDestroyed) {
                    gameState.base.destroyed = true;
                }
            }
        }

        function checkCollision(explosion, missile) {
            const dx = explosion.x - missile.x;
            const dy = explosion.y - missile.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance <= explosion.radius;
        }

        function checkGameOver() {
            const allCitiesDestroyed = gameState.cities.every(city => city.destroyed);
            if (allCitiesDestroyed && gameState.base.destroyed && gameState.bonusCities === 0) {
                gameState.gameOver = true;
            }
        }

        // Add these new functions
        function startNewWave() {
            // Reset wave-specific properties
            gameState.missilesThisWave = Math.min(10 + (gameState.wave - 1) * 2, 30);
            gameState.missilesRemaining = gameState.missilesThisWave;
            gameState.spawnInterval = Math.max(SPAWN_INTERVAL_MS - (gameState.wave - 1) * 50, 500);
            gameState.missileSpeed = MISSILE_SPEED + (gameState.wave - 1) * 0.1;
            
            // Replenish ABMs
            gameState.abmSupply = [10, 10, 10];
            gameState.currentSupply = 0;
            
            // Calculate end of wave bonuses from previous wave
            if (gameState.wave > 1) {
                calculateWaveBonus();
            }

            // Show wave start screen
            gameState.showingWaveScreen = true;
            gameState.waveStartTime = Date.now();
        }

        function calculateWaveBonus() {
            const multiplier = WAVE_MULTIPLIERS[Math.min(gameState.wave - 1, WAVE_MULTIPLIERS.length - 1)];
            
            // Points for surviving cities
            const survivingCities = gameState.cities.filter(city => !city.destroyed).length;
            const cityBonus = survivingCities * POINTS_PER_SAVED_CITY * multiplier;
            
            // Points for unused ABMs
            const unusedABMs = gameState.abmSupply.reduce((sum, supply) => sum + supply, 0);
            const abmBonus = unusedABMs * POINTS_PER_UNUSED_ABM * multiplier;
            
            // Add bonuses to score
            const totalBonus = cityBonus + abmBonus;
            gameState.score += totalBonus;
            
            // Check for bonus cities
            checkBonusCities();
        }

        function checkBonusCities() {
            // Award bonus cities for each 10000 points earned since last check
            const newBonusCities = Math.floor(gameState.score / POINTS_FOR_BONUS_CITY) - 
                                  Math.floor(gameState.lastScore / POINTS_FOR_BONUS_CITY);
            
            if (newBonusCities > 0) {
                gameState.bonusCities += newBonusCities;
                gameState.lastScore = gameState.score;
                rebuildCities();
            }
        }

        function rebuildCities() {
            // Rebuild cities if we have bonus cities available
            while (gameState.bonusCities > 0) {
                const destroyedCity = gameState.cities.find(city => city.destroyed);
                if (!destroyedCity) break;
                
                destroyedCity.destroyed = false;
                gameState.bonusCities--;
            }
        }

        // Add new function to draw wave screen
        function drawWaveScreen() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw wave number
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`WAVE ${gameState.wave}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 - 40);
            
            // Draw wave stats
            ctx.font = '24px Arial';
            ctx.fillText(`Missiles: ${gameState.missilesThisWave}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 20);
            ctx.fillText(`Speed: ${Math.round(gameState.missileSpeed * 100)}%`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 60);
            ctx.fillText(`Spawn Rate: ${Math.round((SPAWN_INTERVAL_MS/gameState.spawnInterval) * 100)}%`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 100);
            
            // Draw "Get Ready!" message
            const timeLeft = Math.ceil((3000 - (Date.now() - gameState.waveStartTime)) / 1000);
            ctx.font = 'bold 36px Arial';
            ctx.fillText(`Get Ready! ${timeLeft}`, CANVAS_WIDTH/2, CANVAS_HEIGHT/2 + 160);
        }

        // Update drawStreakBar function to show correct segments
        function drawStreakBar() {
            const barWidth = 200;
            const barHeight = 20;
            const x = CANVAS_WIDTH - barWidth - 10;
            const y = 120;

            // Draw "STREAK" label
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('STREAK:', x - 10, y + barHeight/2 + 5);

            // Draw background
            ctx.fillStyle = '#333';
            ctx.fillRect(x, y, barWidth, barHeight);

            // Draw segment markers for each power-up threshold (3, 6, 9, 12)
            for (let i = 1; i < 4; i++) {
                const markerX = x + (barWidth * i / 4);
                ctx.fillStyle = '#fff';
                ctx.fillRect(markerX - 1, y, 2, barHeight);
            }

            // Draw streak progress (fills up to next threshold)
            const progress = Math.min(gameState.currentStreak / 3, 4);  // 3 hits per segment, 4 segments total
            ctx.fillStyle = '#0f0';
            ctx.fillRect(x, y, barWidth * (progress / 4), barHeight);

            // Draw power-up boxes below streak bar
            const powerUpY = y + barHeight + 10;
            const powerUpHeight = 30;
            const powerUpWidth = barWidth / MAX_STREAK_LEVELS;

            powerUpMenu.options.forEach((option, index) => {
                const powerUpX = x + (index * powerUpWidth);
                
                // Draw power-up box
                ctx.fillStyle = '#222';  // Default dark background
                
                // If power-up is currently available
                if (index === gameState.maxStreakReached && gameState.powerUpAvailable) {
                    ctx.fillStyle = '#444';  // Highlight box
                    ctx.strokeStyle = '#ff0';
                    ctx.lineWidth = 2;
                    ctx.fillRect(powerUpX, powerUpY, powerUpWidth - 4, powerUpHeight);
                    ctx.strokeRect(powerUpX, powerUpY, powerUpWidth - 4, powerUpHeight);
                    ctx.lineWidth = 1;
                } else {
                    ctx.fillRect(powerUpX, powerUpY, powerUpWidth - 4, powerUpHeight);
                }

                // Draw power-up icon/text
                ctx.fillStyle = (index === gameState.maxStreakReached && gameState.powerUpAvailable) ? '#fff' : '#666';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(option.name.split(' ')[0], powerUpX + powerUpWidth/2, powerUpY + powerUpHeight/2);
            });
        }

        // Add function to completely reset streak state
        function resetStreakState() {
            gameState.currentStreak = 0;
            gameState.maxStreakReached = 0;
            gameState.powerUpAvailable = false;
        }

        // Update activatePowerUp function to handle stacking multipliers
        function activatePowerUp(index) {
            const currentTime = Date.now();
            const POWER_UP_DURATION = 20000; // 20 seconds

            switch(index) {
                case 0: // Wider explosions
                    if (gameState.activePowerUps.explosionBoost.active) {
                        // Stack the multiplier
                        gameState.activePowerUps.explosionBoost.multiplier *= 1.5;
                        console.log('Stacking explosion boost:', gameState.activePowerUps.explosionBoost.multiplier);
                    } else {
                        // First activation
                        gameState.activePowerUps.explosionBoost.active = true;
                        gameState.activePowerUps.explosionBoost.multiplier = 1.5;
                        console.log('First explosion boost activation');
                    }
                    gameState.activePowerUps.explosionBoost.endTime = currentTime + POWER_UP_DURATION;
                    break;
                case 1: // Faster ABMs
                    if (gameState.activePowerUps.speedBoost.active) {
                        // Stack the multiplier
                        gameState.activePowerUps.speedBoost.multiplier *= 1.5;
                    } else {
                        // First activation
                        gameState.activePowerUps.speedBoost.active = true;
                        gameState.activePowerUps.speedBoost.multiplier = 1.5;
                    }
                    gameState.activePowerUps.speedBoost.endTime = currentTime + POWER_UP_DURATION;
                    break;
                case 2: // Rebuild city
                    const destroyedCity = gameState.cities.find(city => city.destroyed);
                    if (destroyedCity) {
                        destroyedCity.destroyed = false;
                        destroyedCity.health = 5;
                        destroyedCity.damagePoints = [];
                    }
                    break;
                case 3: // Triple shot
                    gameState.activePowerUps.tripleShot = true;
                    break;
            }
            
            resetStreakState();
        }
    </script>
</body>
</html>